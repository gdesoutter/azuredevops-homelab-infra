trigger:
- main

name: 'Deploy-Hybrid-Lab-$(Date:yyyyMMdd)$(Rev:.r)'

variables:
  azureServiceConnection: 'Azure-Subscription-Conn' 
  resourceGroupName: 'RG-HYBRID-LAB'
  location: 'francecentral' # Aligné sur ton test manuel réussi
  terraformDirectory: '$(System.DefaultWorkingDirectory)/terraform'
  tfBackendResourceGroup: 'RG-TERRAFORM-STATE'
  tfBackendStorageAccount: 'tfstatelabguillaume' 
  tfBackendContainer: 'tfstate'
  tfBackendKey: 'hyperv-lab.tfstate'

pool:
  name: 'Default' 
  demands:
  - agent.name -equals HOMELAB-WSTOOLS

stages:
  # STAGE 1 : TERRAFORM (Infrastructure & Agent Arc)
  - stage: Terraform_Deploy
    displayName: 'Deploy Infrastructure'
    jobs:
      - job: ProvisionVM
        displayName: 'Terraform Apply'
        steps:
          - task: AzureKeyVault@2
            displayName: 'Get Secrets'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              KeyVaultName: 'KV-labguillaume' 
              SecretsFilter: 'hyperv-password,vm-admin-password,spn-client-id,spn-client-secret,spn-tenant-id,spn-subscription-id'
              RunAsPreJob: true

          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: 'latest'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(terraformDirectory)' 
              backendServiceArm: '$(azureServiceConnection)'
              backendAzureRmResourceGroupName: '$(tfBackendResourceGroup)'
              backendAzureRmStorageAccountName: '$(tfBackendStorageAccount)'
              backendAzureRmContainerName: '$(tfBackendContainer)'
              backendAzureRmKey: '$(tfBackendKey)'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(terraformDirectory)'
              environmentServiceNameAzureRM: '$(azureServiceConnection)'
              commandOptions: '-auto-approve'
            env:
              TF_VAR_hyperv_host: '192.168.1.120'
              TF_VAR_hyperv_user: 'Administrateur'
              TF_VAR_hyperv_password: $(hyperv-password)       
              TF_VAR_vm_admin_password: $(vm-admin-password)
              TF_VAR_client_id: $(spn-client-id)               
              TF_VAR_client_secret: $(spn-client-secret)       
              TF_VAR_tenant_id: $(spn-tenant-id)               
              TF_VAR_subscription_id: $(spn-subscription-id)   
              TF_VAR_resource_group: $(resourceGroupName)
              TF_VAR_location: $(location)

          - powershell: |
              Write-Host "Récupération des outputs Terraform..."
              
              # 1. On récupère la sortie en format JSON (obligatoire pour les listes)
              $jsonOutput = terraform output -json | ConvertFrom-Json
              
              # 2. On extrait la liste 'vm_names' (définie dans ton outputs.tf)
              $vmList = $jsonOutput.vm_names.value
              
              Write-Host ">>> VMs Déployées : $($vmList -join ', ')"

              # 3. Rétro-compatibilité pour le pipeline
              # Si une étape suivante attend une seule variable 'vmName', on lui donne la dernière de la liste
              # (Pour 'DC-02' ce sera parfait car c'est la dernière ajoutée)
              $latestVM = $vmList | Select-Object -Last 1
              
              Write-Host "##vso[task.setvariable variable=vmName;isOutput=true]$latestVM"
            workingDirectory: '$(terraformDirectory)'
            displayName: 'Export VM Name'
            name: 'TFOutput'